<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>in</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>Let’s begin with the first 15 LINQ questions:</p>
<p><strong>1. Explain what is LINQ? Why is it required?</strong></p>
<ul>
<li>LINQ (Language-Integrated Query) is a querying syntax in .NET that
allows querying collections like arrays, lists, and databases.</li>
<li>It provides a unified approach to querying different data sources
using a single syntax.</li>
<li>LINQ improves code readability and reduces the need for complex
loops and conditional logic.</li>
<li>Example:
<code>var evenNumbers = numbers.Where(n =&gt; n % 2 == 0).ToList();</code>
This retrieves even numbers from a list in a clean, readable way.</li>
</ul>
<p><strong>2. What are the types of LINQ?</strong></p>
<ul>
<li>LINQ to Objects: Queries in-memory collections such as arrays or
lists.</li>
<li>LINQ to SQL: Queries SQL Server databases and translates LINQ
queries to SQL.</li>
<li>LINQ to XML: Queries and manipulates XML data.</li>
<li>Example:
<code>XDocument xmlDoc = XDocument.Load("data.xml"); var items = from item in xmlDoc.Descendants("Item") select item;</code></li>
</ul>
<p><strong>3. What are Extension Methods in LINQ?</strong></p>
<ul>
<li>Extension methods allow adding new methods to existing types without
modifying them.</li>
<li>LINQ uses extension methods like <code>Where</code>,
<code>Select</code>, and <code>OrderBy</code> to work with
collections.</li>
<li>They are defined as static methods but invoked like instance
methods.</li>
<li>Example:
<code>public static int Square(this int number) { return number * number; } int result = 5.Square();</code></li>
</ul>
<p><strong>4. What is an Anonymous function in LINQ?</strong></p>
<ul>
<li>Anonymous functions are functions without a name, often used for
short-lived operations.</li>
<li>In LINQ, they are typically defined using lambda expressions.</li>
<li>They help create concise and inline methods for querying data.</li>
<li>Example:
<code>var oddNumbers = numbers.Where(n =&gt; n % 2 != 0).ToList();</code>
uses a lambda as an anonymous function.</li>
</ul>
<p><strong>5. Explain the purpose of LINQ providers in
LINQ?</strong></p>
<ul>
<li>LINQ providers translate LINQ queries into the appropriate format
for the data source.</li>
<li>They allow LINQ to work with different sources like SQL, XML, or
in-memory objects.</li>
<li>Providers implement the <code>IQueryable&lt;T&gt;</code> interface
to enable query execution.</li>
<li>Example: LINQ to SQL translates LINQ queries into SQL commands for
execution on a database.</li>
</ul>
<p><strong>6. List out the three main components of LINQ.</strong></p>
<ul>
<li>Standard Query Operators: Methods like <code>Where</code>,
<code>Select</code>, and <code>GroupBy</code> to query collections.</li>
<li>LINQ Providers: Translate LINQ queries to the target data source’s
format.</li>
<li>Query Syntax and Method Syntax: Two ways to write LINQ queries
(SQL-like and method chaining).</li>
<li>Example: Query syntax:
<code>from n in numbers where n &gt; 10 select n;</code> Method syntax:
<code>numbers.Where(n =&gt; n &gt; 10);</code></li>
</ul>
<p><strong>7. Explain how LINQ is more useful than Stored
Procedures.</strong></p>
<ul>
<li>LINQ provides compile-time syntax checking, reducing runtime
errors.</li>
<li>It integrates seamlessly with C#, improving code
maintainability.</li>
<li>LINQ supports dynamic queries, unlike stored procedures that need
pre-definition.</li>
<li>Example: Dynamic query with LINQ:
<code>var results = data.Where(d =&gt; d.Name.Contains(searchText)).ToList();</code></li>
</ul>
<p><strong>8. Explain why SELECT clause comes after FROM clause in
LINQ.</strong></p>
<ul>
<li>The <code>FROM</code> clause defines the data source, which is
essential before filtering or projecting results.</li>
<li>This order mirrors how method syntax operates
(<code>.Select()</code> follows <code>.Where()</code>).</li>
<li>It enhances code readability and follows logical data access
patterns.</li>
<li>Example:
<code>var results = from n in numbers where n &gt; 0 select n;</code></li>
</ul>
<p><strong>9. In LINQ, how will you find the index of an element using
Where() with Lambda Expressions?</strong></p>
<ul>
<li>LINQ’s <code>Select</code> method can project indexes along with
elements.</li>
<li>You can filter elements based on a condition and use indexing.</li>
<li>This is useful for retrieving the positions of items in a
collection.</li>
<li>Example:
<code>var indexedItems = numbers.Select((num, index) =&gt; new { num, index }).Where(x =&gt; x.num == target).Select(x =&gt; x.index);</code></li>
</ul>
<p><strong>10. Mention what is the role of DataContext classes in
LINQ.</strong></p>
<ul>
<li>DataContext acts as a bridge between LINQ and the database, tracking
changes and submitting updates.</li>
<li>It provides a strongly-typed interface to interact with database
tables.</li>
<li>It simplifies CRUD operations by mapping tables to objects.</li>
<li>Example:
<code>DataContext db = new DataContext(); var customers = db.GetTable&lt;Customer&gt;().ToList();</code></li>
</ul>
<p><strong>11. What are Anonymous Types in LINQ?</strong></p>
<ul>
<li>Anonymous types allow creating objects without defining a
class.</li>
<li>They are useful for projecting data into custom shapes in LINQ.</li>
<li>They provide a quick way to hold data from multiple fields.</li>
<li>Example:
<code>var result = from p in products select new { p.Name, p.Price };</code></li>
</ul>
<p><strong>12. Explain what is LINQ to Objects?</strong></p>
<ul>
<li>LINQ to Objects allows querying in-memory collections like arrays
and lists.</li>
<li>It does not require a database or external data source.</li>
<li>It enables filtering, sorting, and transforming collections with
ease.</li>
<li>Example:
<code>var oddNumbers = numbers.Where(n =&gt; n % 2 != 0).ToList();</code></li>
</ul>
<p><strong>13. What is LINQ in C#?</strong></p>
<ul>
<li>LINQ is a feature in C# that allows querying data from different
sources using a consistent syntax.</li>
<li>It simplifies complex data manipulation tasks.</li>
<li>It provides a readable and maintainable alternative to traditional
loops and conditions.</li>
<li>Example:
<code>var result = from item in collection where item.Age &gt; 18 select item.Name;</code></li>
</ul>
<p><strong>14. When deciding between using Entity Framework and LINQ to
SQL as an ORM, what’s the difference?</strong></p>
<ul>
<li>Entity Framework supports multiple databases, while LINQ to SQL is
limited to SQL Server.</li>
<li>EF provides more advanced features like lazy loading and better
mapping capabilities.</li>
<li>EF is more suitable for complex applications, while LINQ to SQL is
simpler.</li>
<li>Example:
<code>DbContext context = new DbContext(); var users = context.Users.ToList();</code></li>
</ul>
<p><strong>15. Explain what are compiled queries in LINQ?</strong></p>
<ul>
<li>Compiled queries are pre-compiled and stored for reuse, improving
performance.</li>
<li>They are especially beneficial for queries executed multiple
times.</li>
<li>They reduce the overhead of query parsing and translation.</li>
<li>Example:
<code>var compiledQuery = CompiledQuery.Compile((DataContext db) =&gt; db.Customers.Where(c =&gt; c.City == "London"));</code></li>
</ul>
<p><strong>16. What is Expression Trees and how are they used in
LINQ?</strong></p>
<ul>
<li>Expression trees represent code as a data structure, allowing
dynamic modification and execution.</li>
<li>LINQ uses them to translate queries into SQL or other formats for
execution.</li>
<li>They enable advanced scenarios like building dynamic queries at
runtime.</li>
<li>Example:
<code>Expression&lt;Func&lt;int, bool&gt;&gt; expr = num =&gt; num &gt; 5;</code>
dynamically builds a condition for filtering numbers.</li>
</ul>
<p><strong>17. Explain what are Lambda Expressions in LINQ?</strong></p>
<ul>
<li>Lambda expressions are anonymous functions used to create delegates
or expression tree types.</li>
<li>They simplify writing inline functions in LINQ queries.</li>
<li>Syntax: <code>parameters =&gt; expression</code>.</li>
<li>Example:
<code>var evenNumbers = numbers.Where(n =&gt; n % 2 == 0).ToList();</code>
uses a lambda to filter even numbers.</li>
</ul>
<p><strong>18. Could you compare Entity Framework vs LINQ to SQL vs
ADO.NET vs stored procedures?</strong></p>
<ul>
<li><strong>Entity Framework</strong>: ORM supporting multiple
databases, rich features, and lazy loading.</li>
<li><strong>LINQ to SQL</strong>: Lightweight ORM, SQL Server-specific,
easier setup.</li>
<li><strong>ADO.NET</strong>: Manual data access using SQL queries or
stored procedures, high control.</li>
<li><strong>Stored Procedures</strong>: Precompiled SQL, best for
complex batch operations.</li>
<li>Example: EF query:
<code>var data = context.Users.Where(u =&gt; u.IsActive).ToList();</code></li>
</ul>
<p><strong>19. What is the difference between First() and Take(1) in
LINQ?</strong></p>
<ul>
<li><code>First()</code> returns the first matching element and throws
an exception if none found.</li>
<li><code>Take(1)</code> returns a collection with one element or an
empty collection if none found.</li>
<li>Use <code>First()</code> when exactly one element is expected, and
<code>Take(1)</code> for safe enumeration.</li>
<li>Example: <code>var result = numbers.Take(1).ToList();</code>
retrieves the first element safely.</li>
</ul>
<p><strong>20. Explain the difference between Skip() and SkipWhile()
extension methods in LINQ.</strong></p>
<ul>
<li><code>Skip()</code> skips a specified number of elements.</li>
<li><code>SkipWhile()</code> skips elements based on a condition until
it fails.</li>
<li><code>SkipWhile()</code> is useful when skipping based on dynamic
criteria.</li>
<li>Example:
<code>var result = numbers.SkipWhile(n =&gt; n &lt; 10).ToList();</code>
skips numbers less than 10.</li>
</ul>
<p><strong>21. Define what is let clause in LINQ?</strong></p>
<ul>
<li>The <code>let</code> clause allows defining temporary variables in a
query.</li>
<li>It improves readability by storing intermediate results.</li>
<li>It is useful when the same calculation is needed multiple
times.</li>
<li>Example:
<code>var query = from n in numbers let square = n * n where square &gt; 10 select square;</code></li>
</ul>
<p><strong>22. Explain how standard query operators are useful in
LINQ.</strong></p>
<ul>
<li>Standard query operators are predefined methods like
<code>Where</code>, <code>Select</code>, and <code>GroupBy</code>.</li>
<li>They provide a consistent way to filter, transform, and aggregate
data.</li>
<li>They work across different data sources, enhancing code
portability.</li>
<li>Example:
<code>var result = numbers.Where(n =&gt; n % 2 == 0).OrderBy(n =&gt; n).ToList();</code></li>
</ul>
<p><strong>23. When to use First() and when to use FirstOrDefault() in
LINQ?</strong></p>
<ul>
<li>Use <code>First()</code> when you are sure the collection contains
elements.</li>
<li>Use <code>FirstOrDefault()</code> to avoid exceptions if no elements
are found, returning a default value.</li>
<li>It is safer to use <code>FirstOrDefault()</code> in scenarios with
unknown data.</li>
<li>Example:
<code>var firstEven = numbers.FirstOrDefault(n =&gt; n % 2 == 0);</code>
safely retrieves the first even number.</li>
</ul>
<p><strong>24. Could you explain the difference between deferred
execution and lazy evaluation in C#?</strong></p>
<ul>
<li><strong>Deferred execution</strong>: Queries are not executed until
enumerated (e.g., using <code>ToList()</code>).</li>
<li><strong>Lazy evaluation</strong>: Objects are not created or
populated until needed.</li>
<li>Both improve performance by avoiding unnecessary computations.</li>
<li>Example: <code>var query = numbers.Where(n =&gt; n &gt; 10);</code>
only executes when iterated.</li>
</ul>
<p><strong>25. What is an equivalent to the let keyword in chained LINQ
extension method calls?</strong></p>
<ul>
<li>The equivalent is using the <code>Select</code> method to project
intermediate results.</li>
<li>It allows temporary variables within a method chain.</li>
<li>This improves clarity in complex queries.</li>
<li>Example:
<code>var result = numbers.Select(n =&gt; new { n, Square = n * n }).Where(x =&gt; x.Square &gt; 10);</code></li>
</ul>
<p><strong>26. Explain the difference between Select() and Where() in
LINQ.</strong></p>
<ul>
<li><code>Select()</code> projects each element into a new form.</li>
<li><code>Where()</code> filters elements based on a condition.</li>
<li>Use <code>Select()</code> for transformation and
<code>Where()</code> for filtering.</li>
<li>Example:
<code>var squares = numbers.Select(n =&gt; n * n).ToList();</code></li>
</ul>
<p><strong>27. Name some advantages of LINQ over Stored
Procedures.</strong></p>
<ul>
<li>LINQ provides compile-time checks and type safety.</li>
<li>It reduces development time with readable, maintainable code.</li>
<li>LINQ is integrated with C# and allows dynamic queries.</li>
<li>Example: LINQ query:
<code>var results = dbContext.Users.Where(u =&gt; u.IsActive).ToList();</code></li>
</ul>
<p><strong>28. When should I use a Compiled Query in LINQ?</strong></p>
<ul>
<li>Use compiled queries when running the same query multiple times with
different parameters.</li>
<li>They reduce the cost of query parsing and translation.</li>
<li>Ideal for performance-critical applications.</li>
<li>Example:
<code>var compiled = CompiledQuery.Compile((db, id) =&gt; db.Users.Where(u =&gt; u.Id == id));</code></li>
</ul>
<p><strong>29. What are the benefits of Deferred Execution in
LINQ?</strong></p>
<ul>
<li>Deferred execution improves performance by executing queries only
when needed.</li>
<li>It allows chaining multiple operations efficiently.</li>
<li>It supports dynamic query modification before execution.</li>
<li>Example: <code>var query = numbers.Where(n =&gt; n &gt; 10);</code>
does not execute until iterated.</li>
</ul>
<p><strong>30. Name some disadvantages of LINQ over Stored
Procedures.</strong></p>
<ul>
<li>LINQ queries may have performance overhead compared to optimized
stored procedures.</li>
<li>Complex queries might be harder to translate into LINQ.</li>
<li>It depends on the ORM’s translation capabilities.</li>
<li>Example: In complex reporting, stored procedures often outperform
LINQ queries. <strong>31. What is the difference between Select() and
SelectMany() in LINQ?</strong></li>
<li><code>Select()</code> projects each element into a new form,
maintaining the structure of the collection.</li>
<li><code>SelectMany()</code> flattens nested collections into a single
collection.</li>
<li>Use <code>Select()</code> for simple projections and
<code>SelectMany()</code> for handling nested collections.</li>
<li>Example:
<code>var flatList = customers.SelectMany(c =&gt; c.Orders).ToList();</code>
combines all orders from multiple customers into one list.</li>
</ul>
<p><strong>32. Why use AsEnumerable() rather than casting to
IEnumerable<T> in LINQ?</strong></p>
<ul>
<li><code>AsEnumerable()</code> forces LINQ to use in-memory processing
instead of query translation.</li>
<li>It is useful to switch from database evaluation to in-memory
evaluation.</li>
<li>It avoids exceptions from unsupported operations in LINQ to SQL or
LINQ to Entities.</li>
<li>Example:
<code>var localQuery = dbContext.Users.AsEnumerable().OrderBy(u =&gt; u.Name);</code>
performs ordering in memory.</li>
</ul>
<p><strong>33. What is the difference between returning IQueryable<T>
vs. IEnumerable<T> in LINQ?</strong></p>
<ul>
<li><code>IQueryable&lt;T&gt;</code> allows query composition and
deferred execution on the data source.</li>
<li><code>IEnumerable&lt;T&gt;</code> represents in-memory collections
and supports immediate execution.</li>
<li>Use <code>IQueryable&lt;T&gt;</code> for database queries and
<code>IEnumerable&lt;T&gt;</code> for in-memory collections.</li>
<li>Example:
<code>public IQueryable&lt;User&gt; GetActiveUsers() =&gt; db.Users.Where(u =&gt; u.IsActive);</code>
allows further query composition.</li>
</ul>
<p><strong>34. Can you provide a concise distinction between anonymous
methods and lambda expressions in LINQ?</strong></p>
<ul>
<li>Anonymous methods and lambda expressions both define inline
functions.</li>
<li>Lambda expressions are more concise and support expression
trees.</li>
<li>Anonymous methods use the <code>delegate</code> keyword and are more
verbose.</li>
<li>Example: <code>Func&lt;int, int&gt; square = x =&gt; x * x;</code>
is a lambda, while <code>delegate(int x) { return x * x; }</code> is an
anonymous method.</li>
</ul>
<p><strong>35. Filter out the first 3 even numbers from a list using
LINQ.</strong></p>
<ul>
<li>Use <code>Where()</code> to filter even numbers and
<code>Take(3)</code> to select the first three.</li>
<li>The combination allows efficient querying.</li>
<li>It demonstrates deferred execution until enumeration.</li>
<li>Example:
<code>var firstThreeEvens = numbers.Where(n =&gt; n % 2 == 0).Take(3).ToList();</code></li>
</ul>
<p><strong>36. Get the indexes of top items where item value = true
using LINQ.</strong></p>
<ul>
<li>Use <code>Select</code> with indexing to project indexes and
values.</li>
<li>Filter with <code>Where</code> to get only true items.</li>
<li>Extract indexes using another <code>Select</code>.</li>
<li>Example:
<code>var indexes = items.Select((value, index) =&gt; new { value, index }).Where(x =&gt; x.value).Select(x =&gt; x.index).ToList();</code></li>
</ul>
<p><strong>37. Using LINQ to remove elements from a List.</strong></p>
<ul>
<li>LINQ queries are immutable, so filtering creates a new list.</li>
<li>Use <code>Where</code> to exclude elements and reassign the
result.</li>
<li>For actual list modification, combine LINQ with
<code>RemoveAll</code>.</li>
<li>Example:
<code>numbers = numbers.Where(n =&gt; n % 2 != 0).ToList();</code>
removes even numbers from the list.</li>
</ul>
<p><strong>38. Explain the importance of the GroupBy operator in
LINQ.</strong></p>
<ul>
<li><code>GroupBy</code> groups elements based on a key, returning a
collection of groups.</li>
<li>It is useful for aggregation and categorization.</li>
<li>Groups can be further processed with <code>Select</code> or
<code>SelectMany</code>.</li>
<li>Example:
<code>var groups = numbers.GroupBy(n =&gt; n % 2).Select(g =&gt; new { Key = g.Key, Count = g.Count() });</code></li>
</ul>
<p><strong>39. What is the difference between ToList() and ToArray() in
LINQ?</strong></p>
<ul>
<li><code>ToList()</code> converts a sequence to a
<code>List&lt;T&gt;</code>, supporting dynamic resizing.</li>
<li><code>ToArray()</code> converts a sequence to an array with fixed
size.</li>
<li>Use <code>ToList()</code> when frequent additions/removals are
needed.</li>
<li>Example:
<code>var list = numbers.Where(n =&gt; n &gt; 10).ToList(); var array = numbers.Where(n =&gt; n &gt; 10).ToArray();</code></li>
</ul>
<p><strong>40. Explain the difference between Aggregate() and Reduce()
in LINQ.</strong></p>
<ul>
<li><code>Aggregate()</code> applies a function cumulatively to the
sequence, resulting in a single value.</li>
<li>It is useful for custom aggregations beyond simple sums or
counts.</li>
<li>LINQ does not have a direct <code>Reduce()</code> method but
<code>Aggregate()</code> serves a similar purpose.</li>
<li>Example:
<code>var product = numbers.Aggregate((acc, n) =&gt; acc * n);</code>
calculates the product of all numbers.</li>
</ul>
<p><strong>41. What is the purpose of the Join operator in
LINQ?</strong></p>
<ul>
<li><code>Join</code> combines elements from two collections based on a
key.</li>
<li>It supports inner joins, yielding matching elements.</li>
<li>It simplifies complex join logic compared to SQL.</li>
<li>Example:
<code>var result = customers.Join(orders, c =&gt; c.Id, o =&gt; o.CustomerId, (c, o) =&gt; new { c.Name, o.OrderId });</code></li>
</ul>
<p><strong>42. When to use Single() vs. SingleOrDefault() in
LINQ?</strong></p>
<ul>
<li><code>Single()</code> expects exactly one matching element and
throws an exception otherwise.</li>
<li><code>SingleOrDefault()</code> returns the default value if no
elements match, avoiding exceptions.</li>
<li>Use <code>Single()</code> for unique constraints and
<code>SingleOrDefault()</code> for optional results.</li>
<li>Example:
<code>var user = users.SingleOrDefault(u =&gt; u.Id == userId);</code></li>
</ul>
<p><strong>43. Explain the difference between Distinct() and Union() in
LINQ.</strong></p>
<ul>
<li><code>Distinct()</code> removes duplicate elements from a single
collection.</li>
<li><code>Union()</code> combines two collections and removes
duplicates.</li>
<li>Use <code>Distinct()</code> for deduplication and
<code>Union()</code> for set operations.</li>
<li>Example:
<code>var uniqueNumbers = numbers.Distinct().ToList(); var combined = list1.Union(list2).ToList();</code></li>
</ul>
<p><strong>44. How to perform a left join using LINQ?</strong></p>
<ul>
<li>Use <code>GroupJoin</code> or a combination of
<code>DefaultIfEmpty</code> and <code>SelectMany</code>.</li>
<li>It ensures all elements from the left collection are included.</li>
<li>It handles nulls for non-matching right elements.</li>
<li>Example:
<code>var result = from c in customers join o in orders on c.Id equals o.CustomerId into gj from suborder in gj.DefaultIfEmpty() select new { c.Name, suborder?.OrderId };</code></li>
</ul>
<p><strong>45. Explain the role of the Select keyword in LINQ
queries.</strong></p>
<ul>
<li><code>Select</code> projects elements into a new form or shape.</li>
<li>It can transform data by selecting specific properties or creating
anonymous types.</li>
<li>It is equivalent to the projection step in SQL.</li>
<li>Example:
<code>var names = users.Select(u =&gt; u.Name).ToList();</code></li>
</ul>
</body>
</html>
